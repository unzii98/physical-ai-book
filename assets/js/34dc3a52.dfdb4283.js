"use strict";(globalThis.webpackChunkbook=globalThis.webpackChunkbook||[]).push([[200],{4265:(i,e,n)=>{n.r(e),n.d(e,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"digital-twin-sim/gazebo-physics","title":"Physics, Gravity, and Collisions in Gazebo","description":"Gazebo is a standard-bearer in robotics simulation, offering a robust physics engine that calculates rigid body dynamics, collision detection, and environmental forces like gravity and friction.","source":"@site/docs/02-digital-twin-sim/01-gazebo-physics.md","sourceDirName":"02-digital-twin-sim","slug":"/digital-twin-sim/gazebo-physics","permalink":"/physical-ai-book/docs/digital-twin-sim/gazebo-physics","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"2. The Digital Twin (Gazebo & Unity)","permalink":"/physical-ai-book/docs/category/2-the-digital-twin-gazebo--unity"},"next":{"title":"High-Fidelity Rendering in Unity","permalink":"/physical-ai-book/docs/digital-twin-sim/unity-hri"}}');var o=n(4848),t=n(8453);const l={sidebar_position:1},r="Physics, Gravity, and Collisions in Gazebo",a={},c=[{value:"The Physics Engine",id:"the-physics-engine",level:2},{value:"Rigid Body Dynamics",id:"rigid-body-dynamics",level:3},{value:"Handling Collisions",id:"handling-collisions",level:2},{value:"Gravity and Friction",id:"gravity-and-friction",level:2}];function d(i){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...i.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"physics-gravity-and-collisions-in-gazebo",children:"Physics, Gravity, and Collisions in Gazebo"})}),"\n",(0,o.jsx)(e.p,{children:"Gazebo is a standard-bearer in robotics simulation, offering a robust physics engine that calculates rigid body dynamics, collision detection, and environmental forces like gravity and friction."}),"\n",(0,o.jsx)(e.h2,{id:"the-physics-engine",children:"The Physics Engine"}),"\n",(0,o.jsx)(e.p,{children:"At the heart of Gazebo lies the physics engine (defaulting to ODE, but supporting Bullet, Simbody, and DART). This engine solves the equations of motion for every object in the scene at every time step."}),"\n",(0,o.jsx)(e.h3,{id:"rigid-body-dynamics",children:"Rigid Body Dynamics"}),"\n",(0,o.jsx)(e.p,{children:"Robots in Gazebo are modeled as collections of rigid bodies (Links) connected by joints. The physics engine calculates:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Forces & Torques"}),": Applied by motors (joints) or external interactions."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Velocity & Acceleration"}),": How links move in response to forces."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Constraints"}),": How joints limit motion (e.g., a hinge only rotates around one axis)."]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"handling-collisions",children:"Handling Collisions"}),"\n",(0,o.jsx)(e.p,{children:"Collision detection is computationally expensive but vital. Gazebo optimizes this by distinguishing between:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Visual Geometry"}),": High-poly meshes for rendering (what you see)."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Collision Geometry"}),': Simplified shapes (boxes, cylinders, convex hulls) for physics calculations (what the engine "feels").']}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Properly defining collision bitmasks allows you to ignore collisions between specific parts of the robot (e.g., preventing the thigh from colliding with the shin at the joint)."}),"\n",(0,o.jsx)(e.h2,{id:"gravity-and-friction",children:"Gravity and Friction"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gravity"}),": A global force vector (usually ",(0,o.jsx)(e.code,{children:"[0, 0, -9.81]"})," m/s\xb2) applied to all objects with mass."]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Friction"}),": Defined at contact points. Coefficients of friction (",(0,o.jsx)(e.code,{children:"mu"}),", ",(0,o.jsx)(e.code,{children:"mu2"}),") determine how slippery surfaces are. High friction is needed for a humanoid foot to grip the ground and walk; low friction mimics ice."]}),"\n"]}),"\n",(0,o.jsx)(e.p,{children:"Simulating these forces accurately is the difference between a robot that walks and one that instantly falls over."})]})}function h(i={}){const{wrapper:e}={...(0,t.R)(),...i.components};return e?(0,o.jsx)(e,{...i,children:(0,o.jsx)(d,{...i})}):d(i)}},8453:(i,e,n)=>{n.d(e,{R:()=>l,x:()=>r});var s=n(6540);const o={},t=s.createContext(o);function l(i){const e=s.useContext(t);return s.useMemo(function(){return"function"==typeof i?i(e):{...e,...i}},[e,i])}function r(i){let e;return e=i.disableParentContext?"function"==typeof i.components?i.components(o):i.components||o:l(i.components),s.createElement(t.Provider,{value:e},i.children)}}}]);